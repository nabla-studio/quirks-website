---
title: Signing
---

As described before, it is possible to globally access the state of quirks, regardless of the framework used. To facilitate the construction of functions that deal with signing a transaction, we have built a set of utilities within `@quirks/store`:

### getAddress

Return the current account address by chainName.

```ts twoslash
import { getAddress } from "@quirks/store";

const chainName = "osmosis";
const address = getAddress(chainName);
```

### getChain

Return chain info by chainName.

```ts twoslash
import { getChain } from "@quirks/store";

const chainName = "osmosis";
const chain = getChain(chainName);
```

### getOfflineSigner

Return a valid signer class by chainId and signerType (auto, amino or direct)

```ts twoslash
import { getOfflineSigner } from "@quirks/store";

const chainId = "osmosis-1";
const signer = getOfflineSigner(chainId, "auto");
//                                        ^|
```

### getSigningStargateClient

Return an instance of CosmJS Signing Stargate Client.

```ts twoslash
import { getSigningStargateClient } from "@quirks/store";

const chainName = "osmosis";
const signer = getSigningStargateClient(chainName, "auto");
//                                                  ^|
```

### getSigningCosmWasmClient

Return an instance of CosmJS Signing CosmWasm Stargate Client.

```ts twoslash
import { getSigningCosmWasmClient } from "@quirks/store";

const chainName = "osmosis";
const signer = getSigningCosmWasmClient(chainName, "auto");
//                                                  ^|
```

### sign

Signs a transaction using CosmJS Stargate Client on a given chainName. Allows specifying messages, fee, signer type, and memo.

```ts twoslash
import { sign } from "@quirks/store";

const chainName = "osmosis";
const txRaw = sign(chainName, [], "auto", "auto", undefined);
```

### signCW

Signs a CosmWasm transaction using CosmJS Stargate Client on a given chainName. Allows specifying messages, fee, signer type, and memo.

```ts twoslash
import { signCW } from "@quirks/store";

const chainName = "osmosis";
const txRaw = signCW(chainName, [], "auto", "auto", undefined);
```

### signArbitrary

Signs an arbitrary message using the wallet on a given chainId. Allows specifying the signer and message data. (Useful for use case such as auth token generation).

```ts twoslash
import { signArbitrary, getAddress } from "@quirks/store";

const chainName = "osmosis";
const chainId = "osmosis-1";
const address = await getAddress(chainName);
const signature = signArbitrary(chainId, address, "string to sign");
```

### broadcast

Broadcasts a TxRaw transaction on a given chainName. Optional parameters allow specifying timeout and poll interval.

```ts twoslash
import { sign, broadcast } from "@quirks/store";

const chainName = "osmosis";
const txRaw = await sign(chainName, [], "auto", "auto", undefined);
const txResponse = await broadcast(chainName, txRaw, 60_000, 3_000);
```

### broadcastSync

Broadcasts a TxRaw transaction synchronously on a given chainName. It doesn't wait for a response, using polling, but returns the hash of the transaction. (Usefull for use case where you wanna trace the tx using a different method, for example websocket or a state machine).

```ts twoslash
import { sign, broadcastSync } from "@quirks/store";

const chainName = "osmosis";
const txRaw = await sign(chainName, [], "auto", "auto", undefined);
const txResponse = await broadcastSync(chainName, txRaw);
```

## How to sign a send message

In this example we wanna sign a send message, we'll use `osmojs` library to compose the message, but you can use whichever library is most convenient for you.

<Steps>
  <Step>
    Install `osmojs`

    ```package-install
    osmojs
    ```
  </Step>
  <Step>
    Connect a wallet using methods described under `Getting Started section, based on your framework ([react](/docs/getting-started/react/quick-start) or [vue](/docs/getting-started/vue/quick-start)).
  </Step>
  <Step>
    Create an `send` function, just for example purposes we will do a send on the same connected address and Osmosis chain.

    ```ts twoslash title="send.ts"
import { sign, getAddress, broadcast } from "@quirks/store";

export const send = async () => {
      const cosmos = (await import("osmojs")).cosmos;
      const { send } = cosmos.bank.v1beta1.MessageComposer.withTypeUrl;

      const address = getAddress("osmosis");

      const msg = send({
        amount: [
          {
            denom: "uosmo",
            amount: "1",
          },
        ],
        toAddress: address,
        fromAddress: address,
      });

      const txRaw = await sign("osmosis", [msg]);

      const res = await broadcast("osmosis", txRaw);

      return res;
};
```

As you might have noticed, osmojs is imported using dynamic imports, this is to optimize bundle size.
  </Step>
  <Step>
    Invoke the function from anywhere in the app you want to use it, for example in React you can do something like that.

```tsx twoslash
// @filename: send.ts
import { sign, getAddress, broadcast } from "@quirks/store";

export const send = async () => {
  const cosmos = (await import("osmojs")).cosmos;
  const { send } = cosmos.bank.v1beta1.MessageComposer.withTypeUrl;

  const address = getAddress("osmosis");

  const msg = send({
    amount: [
      {
        denom: "uosmo",
        amount: "1",
      },
    ],
    toAddress: address,
    fromAddress: address,
  });

  const txRaw = await sign("osmosis", [msg]);

  const res = await broadcast("osmosis", txRaw);

  return res;
};
// ---cut---
// @filename: send-button.tsx
import { send } from "./send";
// ---cut-start---
import * as React from "react";
// ---cut-end---

export const SendComponent = () => {
    return <button onClick={send}>Send</button>;
};
```
  </Step>
</Steps>

<Callout>
To track the states of transactions and in general of your dapp, it is recommended to use [tanstack query](https://tanstack.com/query/latest), I'll provide some come examples in the future.
</Callout>
